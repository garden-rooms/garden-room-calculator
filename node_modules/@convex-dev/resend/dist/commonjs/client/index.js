import { createFunctionHandle, } from "convex/server";
import { v } from "convex/values";
import { Webhook } from "svix";
export const vEmailId = v.string();
export { vEmailEvent, vStatus, vOptions } from "../component/shared";
function getDefaultConfig() {
    return {
        apiKey: process.env.RESEND_API_KEY ?? "",
        webhookSecret: process.env.RESEND_WEBHOOK_SECRET ?? "",
        initialBackoffMs: 30000,
        retryAttempts: 5,
        testMode: true,
    };
}
async function configToRuntimeConfig(config, onEmailEvent) {
    return {
        apiKey: config.apiKey,
        initialBackoffMs: config.initialBackoffMs,
        retryAttempts: config.retryAttempts,
        testMode: config.testMode,
        onEmailEvent: onEmailEvent
            ? { fnHandle: await createFunctionHandle(onEmailEvent) }
            : undefined,
    };
}
export class Resend {
    component;
    config;
    onEmailEvent;
    /**
     * Creates a Resend component.
     *
     * @param component The component to use, like `components.resend` from
     * `./_generated/api.ts`.
     * @param options The {@link ResendOptions} to use for this component.
     */
    constructor(component, options) {
        this.component = component;
        const defaultConfig = getDefaultConfig();
        this.config = {
            apiKey: options?.apiKey ?? defaultConfig.apiKey,
            webhookSecret: options?.webhookSecret ?? defaultConfig.webhookSecret,
            initialBackoffMs: options?.initialBackoffMs ?? defaultConfig.initialBackoffMs,
            retryAttempts: options?.retryAttempts ?? defaultConfig.retryAttempts,
            testMode: options?.testMode ?? defaultConfig.testMode,
        };
        if (options?.onEmailEvent) {
            this.onEmailEvent = options.onEmailEvent;
        }
    }
    /**
     * Sends an email.
     *
     * Specifically, enqueues your email to be sent as part of efficient, durable email batches
     * managed by the component. The email will be sent as soon as possible, but the component
     * will manage rate limiting and batching for efficiency.
     *
     * This component utilizes idempotency keys to ensure the email is sent exactly once.
     *
     * @param ctx Any context that can run a mutation. You can enqueue an email from
     * either a mutation or an action.
     * @param from The email address to send from.
     * @param to The email address to send to.
     * @param subject The subject of the email.
     * @param html The HTML body of the email.
     * @param text The text body of the email.
     * @param replyTo Optionally, any extra reply to addresses to include in the email.
     * @param headers Extra email headers your want included.
     * @returns The id of the email within the component.
     */
    async sendEmail(ctx, from, to, subject, html, text, replyTo, headers) {
        if (this.config.apiKey === "") {
            throw new Error("API key is not set");
        }
        const id = await ctx.runMutation(this.component.lib.sendEmail, {
            options: await configToRuntimeConfig(this.config, this.onEmailEvent),
            from,
            to,
            subject,
            html,
            text,
            replyTo,
            headers,
        });
        return id;
    }
    /**
     * Cancels an email.
     *
     * This will mark the email as cancelled if it has no already been send to Resend.
     *
     * @param ctx Any context that can run a mutation. You can cancel an email from
     * either a mutation or an action.
     * @param emailId The id of the email to cancel. This was returned from {@link sendEmail}.
     */
    async cancelEmail(ctx, emailId) {
        await ctx.runMutation(this.component.lib.cancelEmail, {
            emailId,
        });
    }
    /**
     * Gets the status of an email.
     *
     * @param ctx Any context that can run a query. You can get the status of an email from
     * an action, mutation, or query.
     * @param emailId The id of the email to get the status of. This was returned from {@link sendEmail}.
     * @returns {@link EmailStatus} The status of the email.
     */
    async status(ctx, emailId) {
        return await ctx.runQuery(this.component.lib.getStatus, {
            emailId,
        });
    }
    /**
     * Handles a Resend event webhook.
     *
     * This will update emails in the component with the status of the email as detected by Resend,
     * and call your `onEmailEvent` mutation if it is set.
     *
     * @param ctx Any context that can run a mutation.
     * @param req The request to handle from Resend.
     * @returns A response to send back to Resend.
     */
    async handleResendEventWebhook(ctx, req) {
        if (this.config.webhookSecret === "") {
            throw new Error("Webhook secret is not set");
        }
        const webhook = new Webhook(this.config.webhookSecret);
        const raw = await req.text();
        const svix_id = req.headers.get("svix-id") ?? "";
        const svix_timestamp = req.headers.get("svix-timestamp") ?? "";
        const svix_signature = req.headers.get("svix-signature") ?? "";
        const payload = webhook.verify(raw, {
            "svix-id": svix_id,
            "svix-timestamp": svix_timestamp,
            "svix-signature": svix_signature,
        });
        const event = payload;
        await ctx.runMutation(this.component.lib.handleEmailEvent, {
            event,
        });
        return new Response(null, {
            status: 201,
        });
    }
}
//# sourceMappingURL=index.js.map